# 50.003 Finals Revision Document
### *Credits:*
- [UMLDiagrams.org](https://www.uml-diagrams.org/use-case-diagrams.html) - UML Use Case Diagram
- [Journal of Systems & Software](https://www.sciencedirect.com/science/article/pii/S0164121213002458) - UML Misuse Case Diagram
- [LucidCharts](https://www.lucidchart.com/pages/uml-class-diagram) - UML Class Diagrams
- [LucidCharts](https://www.youtube.com/watch?v=pCK6prSq8aw) - UML Sequence Diagram
- [Guru99](https://www.guru99.com/equivalence-partitioning-boundary-value-analysis.html) - Equivalence Class Partitioning & Boundary Value Testing
- [Tester Stories](http://testerstories.com/2014/06/path-testing-the-coverage/) - Control Flow Graphs
- [StackOverflow](https://stackoverflow.com/questions/22351222/can-we-change-the-value-of-a-final-variable-of-a-mutable-class) - OBJ04-J's explanation on the`final` term 
- 50.003 Elements of Software Construction Slides - Syllabus and some content
- [Prof Sudipta](https://istd.sutd.edu.sg/people/faculty/sudipta-chattopadhyay) - Comments on Finals
- [Lyqht](https://github.com/lyqht) - Compilation


### *Table of Contents*

  * [UML](#uml)
    + [Use Case Diagram](#use-case-diagram)
      - [Limitations](#limitations)
    + [Sequence Diagram](#sequence-diagram)
    + [State Diagram](#state-diagram)
    + [Class Diagram](#class-diagram)
      - [Association](#association)
      - [Multiplicity](#multiplicity)
  * [Test Design](#test-design)
      - [Equivalence Class Partitioning & Boundary Value Testing](#equivalence-class-partitioning---boundary-value-testing)
    + [Fault-based Testing based on Dirty / Failure Test Cases](#fault-based-testing-based-on-dirty---failure-test-cases)
    + [All coverage metrics](#all-coverage-metrics)
      - [Control Flow Graph](#control-flow-graph)
  * [Test Generation](#test-generation)
    + [Instrumentation](#instrumentation)
    + [Genetic Algorithm](#genetic-algorithm)
    + [Symbolic Execution](#symbolic-execution)
- [Concurrency](#concurrency)
  * [The Need for Refactoring](#the-need-for-refactoring)
    + [Comments](#comments)
    + [Code Smells](#code-smells)
      - [Types of Code Smells](#types-of-code-smells)
  * [Secure Coding Standard](#secure-coding-standard)
    + [XSS Injection](#xss-injection)
  * [Prevention](#prevention)
    + [XML Injection](#xml-injection)
    + [SQL Injection](#sql-injection)
    + [Objection Orientation](#objection-orientation)
      - [OBJ01-J](#obj01-j)
      - [OBJ02-J](#obj02-j)
      - [OBJ04-J](#obj04-j)

> *not testing for 2019 ESC Finals:*
> - Software engineering process e.g. water fall, agile, time-based
> - testing tools eg. junit, selenium, evosuite, klee


## UML

![](https://i.imgur.com/AaMyHoG.png)

> - You will be given a requirement, then you have to model each of the diagrams below. 
> - It is important that you finish all the UML exercises for the telephone network. These were not part of the PSET. Thus, I am assuming that many did not do it. This is probably the time to do. Do not look at the answers, try to do it yourself. As per as UML is concerned, there are way too many correct answers. While grading, we aim to find things that are WRONG, rather than matching through a pre-computed correct answer. 
> 
> Ones highlighted in red are those that are taught in class.


### Use Case Diagram
A use case shows a set of use cases and actors and their relationships and represent system functionality, the requirements of the system from the user’s respective.


- Use Case
    - A description of a set of sequences of actions, including variants, that system performs that yields an observable value to an actor. 
    - Should ideally begin with a verb.
    - Think of the end goal of a user. They don't want to "login" or "sign up." That's not a use case. The use case is more like "make a purchase."

- Actors
    - People or systems that provide or receive information from the system; they are among the stakeholders of a system, which could be human beings, other systems, timers and clocks or hardware devices.
    - Primary Actors: stimulate the system and are the initiators of events (active).
    - Secondary Actors: only receive stimuli from the system (passive).

// ***example***: of use case diagram
![](https://i.imgur.com/hUpEqb6.png)

> The customer makes many checkouts and for any payment he makes, there is only one payment service in charge of it. While checking out, he might require help and by checking out, he would need to make a payment.
> 
> **!! Note**: Usually multiplicity is not required for use case diagrams, but mandatory in class diagrams.

#### Limitations
- Use cases only capture how a system is used
- Use cases do not consider adversarial scenarios
    - Abusing system functionality
    - Hacking and malfunctioning
    - In general, any non-functional requirement, especially security
- Clients and customers are unlikely to provide misuse cases, the onus is on the software engineers. Hence the need for misuse case diagrams arises.

// ***example***: misuse diagram
![](https://i.imgur.com/8I5xVRe.png)

### Sequence Diagram
![](https://i.imgur.com/a2YUI9A.png)



### State Diagram
> If I ask to draw state diagram, I will not tell you the number of states or the names of the states. Thus, you need to pay attention on how to figure out states in a state machine from arbitrary requirement. - Sudipta

// ***example***: state diagram

![](https://i.imgur.com/TMOAiod.png)


### Class Diagram
> Understand the concepts of multiplicity and association clearly. These two are the most complex concepts as per as class diagram is concerned. - Sudipta

#### Association 
| Type of Association | // ***example***: |
| -------- | -------- |
| Bidirectional | ![](https://i.imgur.com/jOzEg6r.png) |
| Unidirectional | ![](https://i.imgur.com/JJduILa.png)|
| Inheritance | ![](https://i.imgur.com/NBavVIx.png) |
| Implement Interface |![](https://i.imgur.com/XkPd9UG.png)|

#### Multiplicity
![](https://i.imgur.com/u2aZ07q.png)

// ***example***: extensive multiplicity 
![](https://i.imgur.com/joY9JqV.png)

*Member Access Modifier Symbols:*
Public (+)
Private (-)
Protected (#)
Package (~)
Derived (/)
Static (underlined)

## Test Design
| Black Box Tests | White Box Tests |
| -------- | -------- | 
| Based on Specification | Based on Code |
| Covers as many specification as possible, hence  better at finding whether code meets the specification or some specs are not implemented | Covers as much implemented behavior as possible, hence better at finding crashes, out-of-bound errors, file handling errors etc. |

#### Equivalence Class Partitioning & Boundary Value Testing
**Equivalent Class Partitioning** is a black box technique (code is not visible to tester) which can be applied to all levels of testing like unit, integration, system, etc. 

In this technique, you divide input conditions into groups (classes). 

- Inputs in the same class should behave similarly in the program.
    - The hypothesis behind this technique is that if one condition/value in a partition passes all others will also pass. Likewise, if one condition in a partition fails, all other conditions in that partition will fail.
    - Then we pick only one value from each partition for testing. 

**Boundary Analysis testing** is used when practically it is impossible to test a large pool of test cases individually

Using both together:
1. In Equivalence Partitioning, first, you divide a set of test condition into a partition that can be considered.
2. In Boundary Value Analysis you then test boundaries between equivalence partitions


![](https://i.imgur.com/aAHL2Pf.png)

![](https://i.imgur.com/6crS107.png)

This form of testing is used to reduce a very large number of test cases to manageable chunks, and is appropriate for calculation-intensive applications with a large number of variables/inputs

### Fault-based Testing based on Dirty / Failure Test Cases
- Can something cause division by zero?
- What if the input type is wrong 
- What if the customer takes an illogical path through your functionality?
    - e.g. Enter invalid email address or URL
- What if mandatory fields are not entered?
    - e.g. Do not enter recipient’s email to send email
- What if the program is aborted abruptly or input or output devices are unplugged?  
    - e.g. Quit a game suddenly in the middle, does it save the state?

### All coverage metrics
- **Node Coverage:** Achieved when the paths identified have a test that goes to every node in the graph.
- **Link Coverage:** Achieved when the paths identified have a test that goes along every link, or line, in the graph. In many cases, node coverage will take care of this.
- **Loop Coverage:** Achieved when the numerous paths identified have tests that explores the interaction between sub-paths within a loop.
- **Statement coverage**: Achieved when the flow of control reached every executable statement of source code at least once.
- **Path Coverage**: Achieved when all linearly independent paths in the program are *executed at least once*
    - A path is defined as the number of nodes executed.
    - A linearly independent path can be defined in terms of what’s called a *control flow graph* of an application.
    - If there is a while loop happening, depending on the input, there can be a lot of paths such that it is impossible to achieve path coverage.

// ***example***: code that has a loop and impossible to achieve path coverage.
```
int f1(int x) {
    int y;
    while (x < 0) {
       if (x >= 0) 
            y = 1/x;
        else
            y++;
        x ++;
    }
}
```

// ***example***: code that has a loop but achieves path coverage. 
```
int f2(int x) {
    int y;
    int i = -10;
    while (i < 0) {
        if (x >= 0)
            y = 1/x;
        else
            y++;
        i++;
    }
}
```

#### Control Flow Graph
For advanced white-box testing, it is often important to capture the control flow of the program. 

// ***example***: basic control flow graphs
| If | Until | While |
| -------- | -------- | -------- |
| ![If statement](http://testerstories.com/files/Path.Test.006.png)    |       ![Until statement](http://testerstories.com/files/Path.Test.007.png)     |       ![While statement](http://testerstories.com/files/Path.Test.008.png)     |

// ***example***: a slightly more complex control flow graph
![](https://i.imgur.com/SXCqLoA.png) 
```
while (cond1)  {
    if (cond2)
        //stmt1
        //stmt4
    else
        //stmt2
}	
//stmt3
```

## Test Generation
You might be asked to: 
- insert or reduce instrumentation code (where and why).
- reason whether it is ok to use random fuzzing, genetic algorithm or symbolic execution for making test inputs in terms of:
    - how probable it is to find the bug
    - performance of the method

### Instrumentation
Instrumentation code helps to check if a certain path / condition is executed. But if there is too much, it will become a **performance overhead**.

> Try making a HTTP get request from your database for all your images and printing to console the Base64 string of every image you got for testing purposes :) You will get why reducing the overhead is important. (don't be like me...)

### Genetic Algorithm
Might be given a model to map the stuff to Genetic Algorithm's operators. 
- Fitness Selection
- Crossover (based on which individual is fitter)
- Mutation for randomized output.
- Chromosome/ Individual Initiation

can be used to generate randomized input such as:
- Strings e.g. Palindrome:
    - Chromosome: A char array of n letters
    - Crossover: for 2 inputs, randomly exchange letters to obtain child
    - Mutation: Randomly flip a letter
    - Fitness function: If the string has achieved palindromic property for >= 1 pair of letters
- Integers e.g. weird specific integer (!! symbolic execution better):
    - Chromosome: a bitvector representing integer 'x'
    - Crossover: for 2 inputs x1, x2, randomly exchange bits to obtain child 
    - Mutation: Randomly flip a bit fo ran input x
    - Fitness function: both statement and branch coverage works 

### Symbolic Execution
It is good for finding out bugs which require specific values of the parameters to be found out.

// ***example:*** method where symbolic execution test generation is appropriate
```
int fun3(int x, int y) {
    int y;
    if (x == 231301)
        y = 5/0;
}
// bug hidden under weird condition branch
// only 2 tests required: x = 231301 and x != 231301
```
# Concurrency

3 Main issues: 
1. **Visibility** 
    - Visibility is solved if all cores are sharing all the memories. Thus, updates to a variable will immediately be visible in the shared memory and also to an arbitrary thread running on an arbitrary core.
2. **Atomicity**
    - Making statements atomic alone does not solve the issue of atomicity. Often according to your requirement, you need to make multiple statements (a code block) atomic. 
    - e.g. consider a stack class that is trying to pop an item. You might need to check the empty stack and the pop together atomically. If only single statements are atomic, this only guarantees that the check and the updates are atomic in isolation, but not together. 
    - To solve such problem, we will still need locks. 
3. **Execution Ordering**
    - Unless the hardware implements a completely deterministic scheduler known to the programmer, the execution order problem will persist. In practice, it is almost impossible to implement a completely deterministic scheduler. 
    - But, using locks can help to restrict the number of possible execution orders. 

*refer to [Java Concurrency notes](https://hackmd.io/iynzv5vhSRyUL9gusM71CQ) for more info on **implementation**.*

## The Need for Refactoring
### Comments
- Used to document
    - Application programmer interfaces (APIs)
    - Choices of data structure and algorithms

- Things that can be included:
    - General description of what it does ***ONLY IF** your code cannot be self-explanatory.* e.g. your variables and method names by right should already speak for themselves what they do. Unless coz of legacy code that you can't override and have to use them.
    - Precondition (@param), Postcondition (output)


```
//precondition: true
//postcondition: if the stack is empty, throws an exception; 
// otherwise, remove the top element in the stack and leave the rest
public synchronized E pop() {
        E obj;
        int len = size();
        obj = peek();
        removeElementAt(len - 1);
        return obj;
}
```

- Don’t overcomment & don't explain how the code works e.g.:
    - Talk about how potential changes to be made in a different method

### Code Smells
Its presence is *not conclusively* a sign of bad code, and depends on application, programming language etc. They are just signs that the code might be rottening and likely to attract maggots (bugs) in near future.

> Do note that Removing one code smell may introduce other code smells.

#### Types of Code Smells
- **Repeated Code**
    - the method should have a single, clear objective.
    - Avoid blackhole classes: classes that start off small but are eventually stacked with too much responsibilities.
- **Long Message Chains**: e.g. A.B().C().D().E()
- **Speculative Generality**: Implement methods/interfaces in advance despite the lack of need for them now
- **Refused Bequest**: Bad Inheritance, where unnecessary methods are inherited.
- **Shotgun Surgery**: Adding a simple feature may require change all over the code
- **Feature Envy**
    - If one class (A) is interacting with another class (B) so frequently to the point that A is like doing the job of B & A is more interested in the job of B than its own.
    - Either B should take care of its own job or just join the classes together.
- **Data Class**: classes that just hold data without much responsibility
    - removing this might lead to data clumps and vice versa.
- **Data Clump**: (Opposite of Data Classes)
    -  Often due to poor program structure or "copypasta programming”.
    -  To check whether or not some data is a data clump, just delete one of the data values and see whether the other values still make sense. If this isn’t the case, this is a good sign that this group of variables should be combined into an object.
        -  If some of the data is passed to other methods, think about passing the entire data object to the method instead of just individual fields (this will increase dependency between the two classes, might be good/bad depending on the situation)
        -  Improves understanding and organization of code. Operations on particular data are now gathered in a single place, instead of haphazardly throughout the code.
        -  Reduces code size.

// ***example***: of Data Clump class
```
public class DataClumpSmell {
        public DataClumpSmell() {
        }
        
        public void doSomething1(int x, int y, int z) {
        }
        
        public void doSomething2(int x, int y, int z) {
        }
        
        public void doSomething3(int x, int y, int z) {
        }

        // do other things without x, y and z
}
```




## Secure Coding Standard
A set of rules which are meant to provide normative requirements for code. Each rule is associated with a metrics for severity (low, medium, and high), likelihood (unlikely, probably, and likely) and remediation cost (high, medium, and low).

Conformance to the rule can be determined through automated analysis (either static or dynamic), formal methods, or manual inspection techniques.

> Types of Misuse we are taught are: XSS, XML, SQL injection.

### XSS Injection
Also known as Cross Site Scripting.
Given a website serves HTML pages to users who request them, 
the attacker is a malicious user of the website who intends to launch an attack on the victim by exploiting an XSS vulnerability in the website. Usually he does so by adding a ` <script> ... </script>` in the html. The victim is a normal user of the website who requests pages from it using his browser.

> // ***example***: of XSS Attack
> ![](https://i.imgur.com/sxVHEtm.png)
e.g. In this text area input element, usually visitors would input a harmless string. However, attackers can write direct code in it to carry out script attacks. This is possible if the code does not carry out sanitization / validation of input data.
*try out XSS injection attacks at this site: http://www.insecurelabs.org/*

## Prevention 

One strategy for avoiding XSS may include forbidding `<script>` tags in inputs. But, it is insufficient for complete input validation and sanitization, as the “sanitized” input may go through normalization afterwards.  

Non-compliant code // ***example***:
```
Pattern pattern = Pattern.compile("[<>]"); 
Matcher matcher = pattern.matcher(in);
if (matcher.find()) {
// Found black listed tag
throw new IllegalStateException();
} else {
// . . .
}
// Normalize
in = Normalizer.normalize(in, Form.NFKC);
```

Hence the strings should be normalized before validating them. 

Compliant code // ***example***:
```
in = Normalizer.normalize(in, Form.NFKC);

Pattern pattern = Pattern.compile("[<>]"); 
Matcher matcher = pattern.matcher(in);
if (matcher.find()) {
// Found black listed tag
throw new IllegalStateException();
} else {
// . . .
}
```

Also, Non-valid ASCII characters should be removed first before normalizing the code, if not these characters may slip unnoticed through the normalizer and be run.

So this meant: 
1. Remove Non-valid ASCII characters
2. Normalize String that has been stripped
3. Validate String

```
public class XSSFixed {
	public static void main(String args[]) {
        // assume "s" is the input that may be susceptible to XSS attacks
        String s = "\uFE64" + "script" + "\uFE65";
        
        // Deletes all non-valid characters
        s = s.replaceAll("[^\\p{ASCII}]", "");
        s = Normalizer.normalize(s, Form.NFKC);
        Pattern pattern = Pattern.compile("<script>");
        Matcher matcher = pattern.matcher(s);
        if (matcher.find()) {
            System.out.println("blacklisted tag");
        } else {
            // . . .
        }
    }
}
```

### XML Injection
Consider an online store which stores purchase orders in XML with the following non-compliant code.
```
private void createXMLStream(BufferedOutputStream outStream, String quantity) 
throws IOException {
    String xmlString = "<item>\n<description>Widget</description>\n" 
                + "<price>500.0</price>\n" +
                "<quantity>" + quantity + "</quantity></item>";
    outStream.write(xmlString.getBytes());
    outStream.flush();
}
```

User selects “iPhone X” and inputs in the quantity field the following:
`1</quantity><price>1.0</price><quantity>1`

The following order is thus generated. 
```
<item>
    <description>iPhone X</description>
    <price>999.0</price>
    <quantity>
        1</quantity><price>1.0</price><quantity>1
    </quantity>
</item>
```

XML (SAX) parser ( org.xml.sax and javax.xml.parsers. SAXParser) interprets the XML such that **the second price field overrides the first**, leaving the price of the item as $1.

//***example***: Compliant code that would sanitize untrusted data passed across a trust boundary would be:
```
private void createXMLStream(BufferedOutputStream outStream, String quantity) 
throws IOException {
    // Write XML string if quantity contains numbers only.
    // Blacklisting of invalid characters can be performed in conjunction.
    if (!Pattern.matches("[0-9]+", quantity)) { /*Format violation*/ }
    String xmlString = "<item>\n<description>Widget</description>\n" 
                + "<price>500.0</price>\n" +
                "<quantity>" + quantity + "</quantity></item>";
    outStream.write(xmlString.getBytes());
    outStream.flush();
}
```

### SQL Injection
An SQL injection vulnerability arises when the original SQL query can be altered to form a different query.

> An SQL command to authenticate a user might take the form:
`SELECT * FROM db_user WHERE username='<USERNAME>' AND
password='<PASSWORD>'`
If it returns any records, the username and password are valid.

**Case 1: With a valid username and any password, the user will be authenticated.** 
The user inputs the following username: 
`validuser' OR '0'='0`, where validuser is a valid username. 

The SQL command becomes
`SELECT * FROM db_user WHERE username='validuser' OR ('0'='0' AND
password=<PASSWORD>)`

**Case 2: With any username, the user will be authenticated.** 
The user inputs the following password: 
`' OR 0='0`
The SQL command becomes
`SELECT * FROM db_user WHERE username='' AND password='' OR 0='0'`


// ***example***: of SQL Injection Compliant Code
```
public class SQLInjectionCompliant {
    String hashPassword(char[] password) {
        // create hash of password
        return null;
    }

    public void doPrivilegedAction(String username, char[] password) throws SQLException {
        Connection connection = getConnection();
        if (connection == null) {
            // Handle error
        }
        try {
            String pwd = hashPassword(password);
            if (username.length() > 8) {
                        // do sth
            }
            String sqlString = "select * from db_user where 
                                username=? and password=?";
            PreparedStatement stmt = connection.prepareStatement(sqlString);
            
            // Use the set*() methods of the PreparedStatement class 
            // to enforce strong type checking.
            // This mitigates the SQL injection vulnerability 
            // because the input is properly escaped by
            // automatic entrapment within double quotes.
            
            stmt.setString(1, username);
            stmt.setString(2, pwd);
            ResultSet rs = stmt.executeQuery();

            if (!rs.next()) {
                throw new SecurityException("User name or password incorrect");
            }
            // Authenticated, proceed
        } finally {
            try {
                connection.close();
            } catch (SQLException x) {
                // forward to handler
            }
        }
    }

    private Connection getConnection() {
        // TODO Auto-generated method stub
        return null;
    }
}
```

### Objection Orientation
Object-orientation allows us to encapsulate data and preserve invariants (sometimes security policies) among class members.

> - OBJ00-J. Limit extensibility of classes and methods with invariants to trusted subclasses only
> - OBJ01-J. Declare data members as private and provide accessible wrapper methods
> - OBJ02-J. Preserve dependencies in subclasses when changing superclasses
> - OBJ04-J. Provide mutable classes with copy functionality to safely allow passing instances to untrusted code
> - OBJ05-J. Defensively copy private mutable class members before returning their references
> - OBJ10-J. Do not use public static non-final variables

#### OBJ01-J
- Data members of a class must be declared private. 
- Using wrapper methods enables appropriate monitoring and control of the modification of data members.


#### OBJ02-J
When developers modify a superclass (during maintenance, for // ***example***:), the developer must ensure that changes in superclasses preserve all the program invariants on which the subclasses depend.

> In other words, don't anyhow add new methods in the parent class that will affect functionalities of the children class. Otherwise, at least throw an Exception in the new method so that whoever is maintaining the child class will notice when they run it OR update the child method appropriately.

#### OBJ04-J
Mutable classes allow code external to the class to alter their instance or class fields. 
Just declaring variables as `final` does not ensure that it is safe from modification, because:
- For a normal object, assigning it as `final` means you cannot assign another object to this reference, but it does not stop you from invoking methods of this object.

// ***example***: of class object variable
```
final ObjectA objA = new ObjectA();
objA.setXXX() // legal
```

- For basic type variables(int, float, boolean etc), they don't have reference, pointer, and object method, so their value cannot be changed.

// ***example***: of primitive variable
```
final int IntegerA = 123;
IntegerA = 321; // not legal
```

// ***example***: of class object variable despite being related to primitive variables
```
final Integer A = new Integer(123);
a.someIntegerMethod(); // legal
```

Hence need to provide means for creating copies of mutable classes so that **disposable instances of such classes can be passed to untrusted code**.

// ***example***:
```
public final class MutableClass {
       private final Date date;
       public MutableClass(MutableClass mc) {
this.date = new Date(mc.date.getTime());
     }
     public MutableClass(Date d) {
this.date = new Date(d.getTime()); 
     }
     public Date getDate() {
return (Date) date.clone(); 
     }
}
```
